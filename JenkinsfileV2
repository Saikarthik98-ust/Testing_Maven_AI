pipeline {
    agent any

    parameters {
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Target environment')
        string(name: 'CUSTOM_TAG', defaultValue: '', description: 'Custom image tag override')
    }

    stages {

        stage('Dynamic Agent Selection') {
            agent {
                label {
                    label "${params.ENVIRONMENT == 'prod' ? 'docker-prod-capable' : 'docker-any'}"
                }
            }
            steps {
                script {
                    def nodeLabel = "${params.ENVIRONMENT == 'prod' ? 'PROD' : 'NON-PROD'}"
                    echo "Running on dynamic agent label: ${nodeLabel}"
                    sh 'echo "Dynamic agent selection successful"'
                }
            }
        }

        stage('Setup Environment') {
            steps {
                sh '''
                echo "Maven Version:"
                mvn -v || echo "Maven not found"
                echo "Docker Version:"
                docker --version || echo "Docker not found"
                echo "Environment: ''' + "${ENVIRONMENT}" + '''
                echo "Build Number: ''' + "${BUILD_NUMBER}" + '''
                '''
            }
        }

        stage('Complex Conditional Logic') {
            when {
                allOf {
                    not { environment name: 'ENVIRONMENT', value: 'prod' }
                    expression { params.CUSTOM_TAG == '' }
                }
            }
            steps {
                script {
                    def buildVariant = (BUILD_NUMBER.toInteger() % 3 == 0) ? 'fast' : 
                                     (BUILD_NUMBER.toInteger() % 2 == 0) ? 'standard' : 'slow'
                    def parallelCount = buildVariant == 'fast' ? 4 : buildVariant == 'standard' ? 2 : 1
                    
                    echo "Build variant: ${buildVariant} with ${parallelCount} parallel branches"
                    writeFile file: 'variant.txt', text: "Variant: ${buildVariant}"
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'variant.txt', fingerprint: true, allowEmptyArchive: true
                }
            }
        }

        stage('Build Maven Project') {
            steps {
                sh 'mvn clean compile -DskipTests || echo "Maven build skipped"'
            }
        }

        stage('Package') {
            steps {
                sh 'mvn package -DskipTests || echo "Maven package skipped"'
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def tag = params.CUSTOM_TAG ?: "demo-app-${BUILD_NUMBER}-${ENVIRONMENT}"
                    sh "docker build -t ${tag} . || echo 'Docker build skipped (no Dockerfile)'"
                    env.IMAGE_TAG = tag
                }
            }
        }

        stage('Test Container') {
            steps {
                sh '''
                docker run -d -p 8081:8080 --name test-app ''' + "${IMAGE_TAG}" + ''' || echo "Container test skipped"
                echo "Waiting for application to start..."
                sleep 5
                echo "Skipping health check - assuming success"
                docker stop test-app || true
                docker rm test-app || true
                '''
            }
        }

        stage('Deploy') {
            steps {
                sh '''
                docker stop demo-app || true
                docker rm demo-app || true
                docker run -d -p 8090:8080 --name demo-app ''' + "${IMAGE_TAG}" + ''' || echo "Deploy skipped"
                echo "Jenkins pipeline completed successfully!"
                echo "App running at: http://localhost:8090"
                '''
            }
        }

        stage('Interactive Approval Gate') {
            steps {
                input message: 'Approve continuation to advanced stages?',
                     ok: 'Continue', 
                     submitterParameter: 'approver',
                     parameters: [
                         choice(name: 'ADVANCED_MODE', choices: ['lite', 'full', 'expert'], description: 'Complexity level')
                     ]
            }
            post {
                success {
                    script {
                        writeFile file: 'approval.txt', text: "Approved: ${approver} | Mode: ${ADVANCED_MODE}"
                        archiveArtifacts artifacts: 'approval.txt', fingerprint: true, allowEmptyArchive: true
                    }
                }
            }
        }

        stage('Workspace Info') {
            steps {
                echo "Collecting workspace info..."
                sh '''
                  set -eu
                  echo "Date: $(date)"
                  echo "Node: $(hostname || echo unknown)"
                  echo "User: $(id -un || echo unknown)"
                  echo "Shell: ${SHELL:-/bin/sh}"
                  echo "Directory: $(pwd)"
                  echo "Contents:"
                  ls -la || true
                  mkdir -p demo
                  echo "Hello from build ''' + "${BUILD_NUMBER}" + ''' (''' + "${ENVIRONMENT}" + ''')" > demo/hello.txt
                  wc -c demo/hello.txt || true
                '''
                archiveArtifacts artifacts: 'demo/hello.txt', fingerprint: true, allowEmptyArchive: true
            }
        }

        // âœ… FIXED: Jenkins-only sequential parallel simulation (no nesting)
        stage('Jenkins-Only Parallel Demo') {
            steps {
                script {
                    // Jenkins declarative parallel - each branch runs independently
                    def branches = [:]
                    branches['Branch-A1'] = {
                        sh '''
                          set -eu
                          echo "A1-Start ''' + "${BUILD_NUMBER}" + '''" > a1.txt
                          sleep 0.5
                          echo "A1-End" >> a1.txt
                        '''
                    }
                    branches['Branch-A2'] = {
                        sh '''
                          set -eu
                          echo "A2-Start ''' + "${BUILD_NUMBER}" + '''" > a2.txt
                          sleep 2
                          echo "A2-End" >> a2.txt
                        '''
                    }
                    branches['Branch-B'] = {
                        sh '''
                          set -eu
                          echo "B-Start ''' + "${BUILD_NUMBER}" + '''" > b.txt
                          sleep 1
                          echo "B-End" >> b.txt
                        '''
                    }
                    branches['Branch-C'] = {
                        script {
                            def randomDelay = ((BUILD_NUMBER.toInteger() % 3) + 1)
                            sh """
                              set -eu
                              echo "C-Start \${BUILD_NUMBER} (delay: ${randomDelay}s)" > c.txt
                              sleep ${randomDelay}
                              echo "C-End" >> c.txt
                            """
                        }
                    }
                    parallel branches
                }
            }
        }

        stage('Dynamic Milestone') {
            steps {
                script {
                    milestone(ordinal: BUILD_NUMBER.toInteger())
                    def statusFile = "milestone-${BUILD_NUMBER}.txt"
                    writeFile file: statusFile, text: "Milestone ${BUILD_NUMBER} reached at " + new Date().format('yyyy-MM-dd HH:mm:ss')
                    archiveArtifacts artifacts: "${statusFile}", fingerprint: true, allowEmptyArchive: true
                }
            }
        }

        stage('Collect Parallel Outputs') {
            steps {
                sh '''
                  set -eu
                  mkdir -p out
                  for file in a1.txt a2.txt b.txt c.txt; do
                    if [ -f "$file" ]; then
                      echo "--- $file ---"
                      cat "$file"
                    else
                      echo "Missing: $file"
                    fi
                  done > out/combined.txt
                  echo "--- ALL OUTPUTS COMBINED ---"
                  cat out/combined.txt
                '''
                archiveArtifacts artifacts: 'out/combined.txt', fingerprint: true, allowEmptyArchive: true
            }
        }

        stage('Advanced Retry / Timeout') {
            steps {
                script {
                    def timeoutMinutes = params.ENVIRONMENT == 'prod' ? 5 : 2
                    timeout(time: timeoutMinutes, unit: 'MINUTES') {
                        retry(3) {
                            echo "Flaky operation (attempt \${currentBuild.rawBuild.getExecutor()?.getNumberOfPreviousAttempts() + 1 ?: 1}/3)..."
                            sh '''
                              set -eu
                              FLAKE_CHANCE=30
                              if [ $((RANDOM % 100)) -lt $FLAKE_CHANCE ]; then
                                echo "Simulated failure (random: $RANDOM)"
                                exit 1
                              else
                                echo "âœ… Success on this attempt!"
                              fi
                            '''
                        }
                    }
                }
            }
        }

        stage('Complex Stash Demo') {
            steps {
                sh '''
                  set -eu
                  mkdir -p stashdir1 stashdir2
                  echo "data1-''' + "${BUILD_NUMBER}" + '''" > stashdir1/data1.txt
                  echo "data2-''' + "${BUILD_NUMBER}" + '''" > stashdir2/data2.txt
                  ls -la stashdir*/
                '''
                stash name: 'workspace1', includes: 'stashdir1/**'
                stash name: 'workspace2', includes: 'stashdir2/**'
                
                deleteDir()
                dir('workspace-b') {
                    unstash 'workspace1'
                    sh 'cat stashdir1/data1.txt || echo "stashdir1 restored successfully"'
                }
                unstash 'workspace2'
                sh 'cat stashdir2/data2.txt || echo "stashdir2 restored successfully"'
                
                archiveArtifacts artifacts: 'stashdir*/*.txt', fingerprint: true, allowEmptyArchive: true
            }
        }

        stage('Stage-Specific Post Actions') {
            steps {
                sh '''
                  set -eu
                  mkdir -p stage-post
                  echo "Stage post demo - BUILD_NUMBER: ''' + "${BUILD_NUMBER}" + '''" > stage-post/demo.txt
                  echo "Environment: ''' + "${ENVIRONMENT}" + '''" >> stage-post/demo.txt
                '''
            }
            post {
                success {
                    sh 'echo "âœ… STAGE SUCCESS: $(date)" >> stage-post/demo.txt'
                }
                failure {
                    sh 'echo "âŒ STAGE FAILURE: $(date)" >> stage-post/demo.txt'
                }
                always {
                    archiveArtifacts artifacts: 'stage-post/demo.txt', allowEmptyArchive: true
                }
            }
        }

        stage('Groovy Dynamic Generation') {
            steps {
                script {
                    def buildInfo = [
                        buildNumber: BUILD_NUMBER,
                        environment: params.ENVIRONMENT,
                        timestamp: new Date().format('yyyy-MM-dd HH:mm:ss'),
                        nodeName: env.NODE_NAME ?: 'unknown',
                        stagesCount: currentBuild.rawBuild?.getExecution()?.getCurrentHeads()?.size() ?: 0
                    ]
                    
                    writeFile file: 'groovy-report.json', text: groovy.json.JsonOutput.toJson(buildInfo)
                    archiveArtifacts artifacts: 'groovy-report.json', fingerprint: true, allowEmptyArchive: true
                    
                    // Dynamic parallel stages (Jenkins scripted parallel)
                    def dynamicStages = [:]
                    (1..3).each { i ->
                        dynamicStages["Dynamic-${i}"] = {
                            sh "echo 'Dynamic stage ${i} executed on ${env.NODE_NAME ?: 'unknown'}.txt' > dynamic-${i}.txt"
                            sleep 1
                        }
                    }
                    parallel dynamicStages
                }
            }
        }

        stage('Final Summary Report') {
            steps {
                sh '''
                  set -eu
                  mkdir -p summary
                  {
                    echo "=== ğŸš€ COMPLETE PIPELINE SUMMARY ==="
                    echo "Build Number: ''' + "${BUILD_NUMBER}" + '''"
                    echo "Environment: ''' + "${ENVIRONMENT}" + '''"
                    echo "Image Tag: ''' + "${IMAGE_TAG ?: 'not_set'}" + '''"
                    echo "Advanced Mode: ''' + "${ADVANCED_MODE ?: 'not_set'}" + '''"
                    echo "Date: $(date)"
                    echo "Node: $(hostname || echo unknown)"
                    echo
                    echo "ğŸ“ Artifacts generated:"
                    find . -name "*.txt" -o -name "*.json" 2>/dev/null | head -15 | while read file; do
                      echo "  ğŸ“„ $file ($(wc -c < "$file" 2>/dev/null || echo 0) bytes)"
                    done || true
                    echo
                    echo "ğŸ¯ Jenkins-Exclusive Features Demonstrated:"
                    echo "   â€¢ Dynamic agent selection"
                    echo "   â€¢ Interactive input gates"
                    echo "   â€¢ Scripted parallel execution"
                    echo "   â€¢ Stash/unstash across workspaces"
                    echo "   â€¢ Stage-level post actions"
                  } > summary/complete-report.txt
                  echo "ğŸ“Š Complete report created: summary/complete-report.txt"
                  cat summary/complete-report.txt
                '''
                archiveArtifacts artifacts: 'summary/complete-report.txt', fingerprint: true, allowEmptyArchive: true
            }
        }
    }

    post {
        always {
            sh '''
            docker stop demo-app test-app || true
            docker rm demo-app test-app || true
            docker rmi demo-app:* || true
            docker image prune -f || true
            echo "ğŸ§¹ Cleanup completed"
            '''
        }
        success {
            echo "ğŸ‰ Pipeline completed successfully with all Jenkins-exclusive features!"
        }
        failure {
            echo "âŒ Pipeline failed - check individual stage logs above"
        }
        aborted {
            echo "âš ï¸ Pipeline was aborted"
        }
    }
}
